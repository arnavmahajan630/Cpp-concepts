Inheritance is quite complex since we have many types of inheritances
*public
*private
*protected

=> for now ill focus only on public later Ill come back with books and refferences
for private and protected



A Derived class does not inherit the following stuff from base class:
Constructor
Destructor
overloaded assignment operator
friend functions

=> However the derived class equivalents can invoke base class versions

# !!! if we initialize a class Dervied D with param then it's not like the Base param will be called
while making of derived first the base no args is called then derived param is called
we need to explicitly call for this Base constructor with param in derived if we want it to be called 


# When we normally did Derived(int x) then Base () with no args get called auto this means 
the vlaue of base variable inherited by derived class get's set according to default constructor 
If we want our own custom value to be set in that case what we need to do is 
   Derived(int x) : Base{x}, double_val(0){cout << "derived from base constructor called" << endl;}
This explicitly says that construct whatever inherited from base with Base(x) and base x is defined in the base class


# Copy Move and overload for derived class
=> Invoking copy/move and overload assignment of base from dervied 

Synatax generic for copy constructor
Derived::Derived(const Derived & other) : Base(other), {// derived initializer list} {
   // code for derived
}

Derived::Derived &operator=(cont Derived &rhs) {
   if(this != &rhs) {
      // sliced base and assign it's part
       // assign the derived part
   }
   return *this;
}

# Usually they are not needed compiler will call it by it'self


# For overloading it's very simple 
display() would overload the method for derived class
Account::depoist() would call the parent deposit method

